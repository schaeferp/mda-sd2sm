using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using Egp.Mda.Transformation.Domain;

namespace Egp.Mda.Transformation.Core
{
    /// <summary>
    ///     Provides functionality to deserialize XMI data into an intermediate
    ///     format which may be passed to further processing measures.
    ///     This implementation expects XMI format 2.4.1 as generated by MagicDraw (c).
    /// </summary>
    public class MagicDrawXmiDeserializer : XmiDeserializerBase
    {
        #region XML Prefix Constants

        private const string XmiPrefix = "xmi";
        private const string UmlPrefix = "uml";

        #endregion

        #region XML Attribute Name Constants

        private const string IdAttributeName = "id";
        private const string TypeAttributeName = "type";
        private const string NameAttributeName = "name";
        private const string RepresentsAttributeName = "represents";
        private const string IdRefAttributeName = "idref";
        private const string ReceiveEventAttributeName = "receiveEvent";
        private const string SendEventAttributeName = "sendEvent";

        #endregion

        #region XML Tag Name Constants

        private const string OwnedAttributeTagName = "ownedAttribute";
        private const string PackagedElementTagName = "packagedElement";
        private const string LifelineTagName = "lifeline";
        private const string MessageTagName = "message";
        private const string MessageSortAttributeName = "messageSort";
        private const string FragmentTagName = "fragment";
        private const string MessageAttributeName = "message";
        private const string CoveredTagName = "covered";
        private const string ModelTagName = "Model";
        private const string BodyTagName = "body";

        #endregion

        #region XML Prefix XNames

        private XName _umlModel;
        private XName _xmiIdAttribute;
        private XName _xmiIdRefAttribute;
        private XName _xmiTypeAttribute;

        #endregion

        protected override XmiSequenceDiagramModel From(XDocument document)
        {
            LookupXmlNs(document);
            return new XmiSequenceDiagramModel {PackagedElements = FetchPackagedElements(document)};
        }

        /// <summary>
        ///     Fetches all PackagedElement nodes as contained in the given document.
        /// </summary>
        /// <param name="document">The input XMI document.</param>
        /// <returns>A mapping containing all contained PackagedElement nodes, with their XMI-Id as a key.</returns>
        private IDictionary<string, PackagedElement> FetchPackagedElements(XContainer document)
        {
            if (document == null) throw new ArgumentNullException("document");
            var umlModel = document.Descendants(_umlModel);
            var xPackagedElements = umlModel.Descendants(PackagedElementTagName);
            return xPackagedElements.Select(xElement =>
                new PackagedElement
                {
                    XmiId = ValueOrDefault(xElement.Attribute(_xmiIdAttribute)),
                    Name = ValueOrDefault(xElement.Attribute(NameAttributeName)),
                    XmiType = ValueOrDefault(xElement.Attribute(_xmiTypeAttribute)),
                    OwnedAttributes = FetchOwnedAttributesFor(xElement),
                    Fragments = FetchFragmentsFor(xElement),
                    Lifelines = FetchLifelinesFor(xElement),
                    Messages = FetchMessagesFor(xElement)
                }
                ).ToDictionary(key => key.XmiId);
        }

        /// <summary>
        ///     Fetches all Message nodes being hooked under the given node.
        /// </summary>
        /// <param name="node">The root element node to begin searching from.</param>
        /// <returns>A mapping containing all Message nodes being hooked in the given scope, with their XMI-Id as a key.</returns>
        private IDictionary<string, Message> FetchMessagesFor(XContainer node)
        {
            var xMessages = node.Descendants(MessageTagName);
            return xMessages.Select(xMessage => new Message
            {
                XmiId = xMessage.Attribute(_xmiIdAttribute).Value,
                Name = ValueOrDefault(xMessage.Attribute(NameAttributeName)),
                XmiType = xMessage.Attribute(_xmiTypeAttribute).Value,
                ReceiveEvent = xMessage.Attribute(ReceiveEventAttributeName).Value,
                SendEvent = xMessage.Attribute(SendEventAttributeName).Value,
                Sort = ValueOrDefault(xMessage.Attribute(MessageSortAttributeName))
            }).ToDictionary(ownedAttribute => ownedAttribute.XmiId);
        }

        /// <summary>
        ///     Fetches all Fragment nodes being hooked under the given node.
        /// </summary>
        /// <param name="node">The root element node to begin searching from.</param>
        /// <returns>A mapping containing all Fragment nodes being hooked in the given scope, with their XMI-Id as a key.</returns>
        private IDictionary<string, Fragment> FetchFragmentsFor(XContainer node)
        {
            var result = new Dictionary<string, Fragment>();
            var xFragments = node.Descendants(FragmentTagName);
            foreach (var xFragment in xFragments)
            {
                var fragment = new Fragment
                {
                    XmiId = xFragment.Attribute(_xmiIdAttribute).Value,
                    XmiType = xFragment.Attribute(_xmiTypeAttribute).Value,
                    Body = ValueOrDefault(xFragment.Descendants(BodyTagName).FirstOrDefault()),
                    Message = ValueOrDefault(xFragment.Attribute(MessageAttributeName))
                };
                var xCovereds = xFragment.Descendants(CoveredTagName);
                foreach (var xCovered in xCovereds) fragment.Covered.Add(xCovered.Attribute(_xmiIdRefAttribute).Value);
                result.Add(fragment.XmiId, fragment);
            }
            return result;
        }

        /// <summary>
        ///     Fetches all OwnedAttribute nodes being hooked under the given node.
        /// </summary>
        /// <param name="node">The root element node to begin searching from.</param>
        /// <returns>A mapping containing all OwnedAttribute nodes being hooked in the given scope, with their XMI-Id as a key.</returns>
        private IDictionary<string, OwnedAttribute> FetchOwnedAttributesFor(XContainer node)
        {
            var xOwnedAttributes = node.Descendants(OwnedAttributeTagName);
            return xOwnedAttributes.Select(xOwnedAttribute => new OwnedAttribute
            {
                XmiId = ValueOrDefault(xOwnedAttribute.Attribute(_xmiIdAttribute)),
                Name = ValueOrDefault(xOwnedAttribute.Attribute(NameAttributeName)),
                XmiType = ValueOrDefault(xOwnedAttribute.Attribute(_xmiTypeAttribute)),
                Type = ValueOrDefault(xOwnedAttribute.Attribute(TypeAttributeName))
            }).ToDictionary(ownedAttribute => ownedAttribute.XmiId);
        }

        /// <summary>
        ///     Fetches all Lifeline nodes being hooked under the given node.
        /// </summary>
        /// <param name="node">The root element node to begin searching from.</param>
        /// <returns>A mapping containing all Lifeline nodes being hooked in the given scope, with their XMI-Id as a key.</returns>
        private IDictionary<string, Lifeline> FetchLifelinesFor(XContainer node)
        {
            var xLifelines = node.Descendants(LifelineTagName);
            return xLifelines.Select(xLifeline => new Lifeline
            {
                XmiId = xLifeline.Attribute(_xmiIdAttribute).Value,
                XmiType = xLifeline.Attribute(_xmiTypeAttribute).Value,
                Represents = xLifeline.Attribute(RepresentsAttributeName).Value
            }).ToDictionary(ownedAttribute => ownedAttribute.XmiId);
        }

        /// <summary>
        ///     Looks up any required XMLNS URLs and stores them for later usage.
        /// </summary>
        /// <param name="document">The input XMI document.</param>
        private void LookupXmlNs(XDocument document)
        {
            _xmiIdAttribute = LookupXName(XmiPrefix, IdAttributeName, document);
            _xmiTypeAttribute = LookupXName(XmiPrefix, TypeAttributeName, document);
            _xmiIdRefAttribute = LookupXName(XmiPrefix, IdRefAttributeName, document);
            _umlModel = LookupXName(UmlPrefix, ModelTagName, document);
        }

        /// <summary>
        ///     Convenience method for null-checking <see cref="XAttribute" />s.
        /// </summary>
        /// <param name="attribute">The (possibly null) attribute.</param>
        /// <param name="defaultVal">The value to return if the given attribute is null. Empty String by default.</param>
        /// <returns>The given attribute's value, if existing. The (given) default value, otherwise.</returns>
        private static string ValueOrDefault(XAttribute attribute, string defaultVal = "")
        {
            return null == attribute
                ? defaultVal
                : attribute.Value;
        }

        /// <summary>
        ///     Convenience method for null-checking <see cref="XElement" />s.
        /// </summary>
        /// <param name="element">The (possibly null) element.</param>
        /// <param name="defaultVal">The value to return if the given element is null. Empty String by default.</param>
        /// <returns>The given element's value, if existing. The (given) default value, otherwise.</returns>
        private static string ValueOrDefault(XElement element, string defaultVal = "")
        {
            return null == element
                ? defaultVal
                : element.Value;
        }
    }
}